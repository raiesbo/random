-- SERIAL vs IDENTITY
create table "users" (
	"user_id" SERIAL PRIMARY KEY, -- Autoincrement numbers starting from 1
	"user_name" VARCHAR
);

INSERT INTO users (user_name)
values ('REB 2'), ('Mmmm');

SELECT * FROM users;

-- IDENTITY
create table "users2" (
	"user_id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Autoincrement numbers starting from 1
	"user_name" VARCHAR
);

INSERT INTO users2 (user_name)
values ('REB 2'), ('Mmmm');

SELECT * FROM users2;

-- IDENTITY WITH ALWAYS DEFAULT KEY VALUES
create table "users3" (
	"user_id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, -- Does not accept adding a value when creating a row
	"user_name" VARCHAR
);

INSERT INTO users3 (user_name)
values ('REB 2'), ('Mmmm');

SELECT * FROM users3;

INSERT INTO users3 
values (4, 'REB 2');

-- PRIMERY KEY FROM COMBINED FIELDS:
CREATE TABLE user_dual (
	id1 int,
	id2 int,
	PRIMARY KEY (id1, id2) -- This indicates that the combination of both elements needs to be unique.
	-- It is not about each element to be unique, but the combination of both.
)

-- UUIDs
select gen_random_uuid();

CREATE TABLE students (
	id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
	name VARCHAR not NULL
);

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
select uuid_generate_v4();

DROP EXTENSION "uuid-ossp";

-- SEQUENCE
CREATE SEQUENCE user_sequence;
SELECT nextval('user_sequence'); -- This triggers the next value and can no longer be assigned to an insert.
SELECT currval('user_sequence'); -- Shows current sequence value.

CREATE TABLE "user7" (
	user_id INTEGER PRIMARY KEY DEFAULT  nextval('user_sequence'),
	username VARCHAR
);

INSERT INTO user7 (username)
	values ('rando');

SELECT * FROM user7;

DROP SEQUENCE user_sequence;

